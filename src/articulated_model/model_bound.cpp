#include "fcl/articulated_model/model_bound.h"

#include "fcl/articulated_model/model.h"
#include "fcl/articulated_model/model_config.h"
#include "fcl/articulated_model/link.h"
#include "fcl/articulated_model/joint.h"
#include "fcl/articulated_model/joint_config.h"
#include "fcl/ccd/interpolation/interpolation.h"
#include "fcl/ccd/interpolation/interpolation_factory.h"

#include <boost/assert.hpp>

namespace fcl 
{

ModelBound::ModelBound(boost::shared_ptr<Model> model, 
	boost::shared_ptr<const ModelConfig> cfg_start, boost::shared_ptr<const ModelConfig> cfg_end) :
  model_(model),
  cfg_start_(cfg_start),
  cfg_end_(cfg_end)
{
	initJointsInterpolations();
	initJointsParentTree();
}

void ModelBound::initJointsInterpolations()
{
	std::vector<boost::shared_ptr<fcl::Joint> > joints = model_->getJoints();
	std::vector<boost::shared_ptr<fcl::Joint> >::iterator it;

	for (it = joints.begin(); it != joints.end(); ++it)
	{
		boost::shared_ptr<Joint>& joint = (*it);

		// for NOW works just for JT_PRISMATIC, JT_REVOLUTE joint types
		BOOST_ASSERT_MSG((joint->getJointType() == JT_PRISMATIC) || (joint->getJointType() == JT_REVOLUTE),
			"Joint type not supported yet");

		const std::string& joint_name = joint->getName();
		const InterpolationType joint_interpolation_type = model_->getJointInterpolationType(joint_name);

		const FCL_REAL joint_start_value = cfg_start_->getJointConfig(joint_name).getValue(0);
		const FCL_REAL joint_end_value = cfg_end_->getJointConfig(joint_name).getValue(0);

		joints_interpolations_[joint_name] =
			InterpolationFactory::instance().create(joint_interpolation_type, joint_start_value, joint_end_value);
	}	
}

void ModelBound::initJointsParentTree()
{
	std::map<std::string, std::string> link_parent_tree;

	model_->initTree(link_parent_tree);
	model_->initRoot(link_parent_tree);	

	boost::shared_ptr<const Link> root_link = model_->getRoot();

	constructParentTree(link_parent_tree, joint_parent_tree_, root_link);
}

void ModelBound::constructParentTree(const std::map<std::string, std::string>& link_parent_tree,
	std::map<std::string, std::string>& joint_parent_tree, boost::shared_ptr<const Link>& link)
{	
	std::vector<boost::shared_ptr<const Joint> > child_joints = link->getChildJoints();
	boost::shared_ptr<const Joint> parent_joint = link->getParentJoint();
	std::vector<boost::shared_ptr<const Joint> >::const_iterator it;

	for (it = child_joints.begin(); it != child_joints.end(); ++it)
	{
		boost::shared_ptr<const Joint> joint = (*it);
		boost::shared_ptr<const Link> child_link = joint->getChildLink();

		if (parent_joint.use_count() != 0)
		{
			joint_parent_tree[joint->getName()] = parent_joint->getName();
		}		

		if (child_link.use_count() != 0)
		{
			constructParentTree(link_parent_tree, joint_parent_tree_, child_link);
		}
	}
}

FCL_REAL ModelBound::getMotionBound(const std::string& link_name, const FCL_REAL& time, 
	const Vec3f& direction, const FCL_REAL max_distance_from_joint_center)
{
	FCL_REAL motion_bound = 0;
	
	setCurrentTime(time);
	setCurrentDirection(direction);
	
	resetAngularBoundAccumulation();

	boost::shared_ptr<const Link> link = model_->getLink(link_name);
	BOOST_ASSERT_MSG(link.use_count() != 0.0, "Link with with given name doesn't exist!");

	boost::shared_ptr<const Joint> joint = link->getParentJoint();
	if (joint.use_count() == 0.0)
	{
		// no joint's parent means motion bound equals 0.0
		return 0.0;
	}

	std::string last_joint_name = joint->getName();
	boost::shared_ptr<const Joint> last_joint = model_->getJoint(last_joint_name);
	std::vector<boost::shared_ptr<const Joint> > joints_chain = getJointsChainFromLastJoint(last_joint_name);		

	// add motion bound generated by other joints
	motion_bound += getJointsChainMotionBound(joints_chain);

	// add motion bound for collision object (rigid body) fixed to the link of the last joint
	motion_bound += getObjectMotionBoundInJointFrame(last_joint, max_distance_from_joint_center);

	return motion_bound;
}

std::vector<boost::shared_ptr<const Joint> >
	ModelBound::getJointsChainFromLastJoint(const std::string& last_joint_name) const
{
	std::vector<boost::shared_ptr<const Joint> > joints_chain;

	boost::shared_ptr<const Joint> joint = model_->getJoint(last_joint_name);

	while (joint.use_count() != 0)
	{
		joints_chain.push_back(joint);

		joint = getJointParent(joint);
	}

	return joints_chain;
}

boost::shared_ptr<const Joint> ModelBound::getJointParent(const boost::shared_ptr<const Joint>& joint) const 
{
	std::string joint_name = joint->getName();
	std::string parent_name = getJointParentName(joint_name);

	return model_->getJoint(parent_name);
}

std::string ModelBound::getJointParentName(const std::string& joint_name) const
{
	std::map<std::string, std::string>::const_iterator it = joint_parent_tree_.find(joint_name);

	//BOOST_ASSERT_MSG((it != joint_parent_tree_.end()), "Joint name is not valid");
	if (it == joint_parent_tree_.end() )
	{
		return "";
	}

	return it->second;
}

FCL_REAL ModelBound::getJointsChainMotionBound(std::vector<boost::shared_ptr<const Joint> >& joints_chain) const
{
	FCL_REAL motion_bound = 0;

	// remove root joint
	pop(joints_chain);

	std::vector<boost::shared_ptr<const Joint> >::iterator it;

	for (it = joints_chain.begin(); it != joints_chain.end(); ++it)
	{
		boost::shared_ptr<const Joint>& joint = *it;

		motion_bound += getMotionBoundInParentFrame(joint);
	}

	return motion_bound;
}

FCL_REAL ModelBound::getMotionBoundInParentFrame(boost::shared_ptr<const Joint>& joint) const 
{
	boost::shared_ptr<const Joint> parent = getJointParent(joint);

	if (isRoot(parent) )
	{
		return getDirectionalMotionBoundInParentFrame(joint);
	}
	else
	{
		return getSimpleMotionBoundInParentFrame(joint);
	}
}

FCL_REAL ModelBound::getDirectionalMotionBoundInParentFrame(boost::shared_ptr<const Joint>& joint) const 
{
	FCL_REAL motion_bound = 0;

	boost::shared_ptr<const Joint> parent = getJointParent(joint);

	motion_bound += (getLinearVelocityBoundGeneratedByJoint(parent) * getCurrentDirection() ).length();
	motion_bound += getAccumulatedAngularBound(parent, true) * getVectorLengthBoundToParent(joint);

	return motion_bound;
}

FCL_REAL ModelBound::getSimpleMotionBoundInParentFrame(boost::shared_ptr<const Joint>& joint) const 
{
	FCL_REAL motion_bound = 0;

	boost::shared_ptr<const Joint> parent = getJointParent(joint);

	motion_bound += getAbsoluteLinearVelocityBoundGeneratedByJoint(parent);
	motion_bound +=  getAccumulatedAngularBound(parent) * getVectorLengthBoundToParent(joint);

	return motion_bound;
}

FCL_REAL ModelBound::getObjectMotionBoundInJointFrame(boost::shared_ptr<const Joint>& joint,
	const FCL_REAL max_distance_from_joint_center)
{
	FCL_REAL motion_bound = 0;

	motion_bound += getAbsoluteLinearVelocityBoundGeneratedByJoint(joint);
	motion_bound += getAccumulatedAngularBound(joint) * max_distance_from_joint_center;

	return motion_bound;
}

bool ModelBound::isRoot(const boost::shared_ptr<const Joint>& joint) const
{
	boost::shared_ptr<const Joint> parent = getJointParent(joint);	

	return (parent.use_count() == 0);
}

Vec3f ModelBound::getLinearVelocityBoundGeneratedByJoint(boost::shared_ptr<const Joint>& joint) const
{
	if (isJointTranslational(joint) )
	{
		return joint->getAxis() * getInterpolationVelocityBound(joint);
	}
	else
	{
		return Vec3f(0.0, 0.0, 0.0);		
	}
}


FCL_REAL ModelBound::getAbsoluteLinearVelocityBoundGeneratedByJoint(boost::shared_ptr<const Joint>& joint) const
{
	if (isJointTranslational(joint) )
	{
		return std::abs(getInterpolationVelocityBound(joint));
	}
	else
	{
		return 0.0;		
	}
}

FCL_REAL ModelBound::getInterpolationVelocityBound(boost::shared_ptr<const Joint>& joint) const
{
	boost::shared_ptr<const Interpolation> interp = getInterpolation(joint);	

	return interp->getVelocityBound(getCurrentTime() );
}

boost::shared_ptr<Interpolation> ModelBound::getInterpolation(boost::shared_ptr<const Joint>& joint) const
{
	std::string joint_name = joint->getName();

	std::map<std::string, boost::shared_ptr<Interpolation> >::const_iterator it = joints_interpolations_.find(joint_name);

	BOOST_ASSERT_MSG((it != joints_interpolations_.end()), "Joint name not valid");

	return it->second;
}

Vec3f ModelBound::getAngularVelocityBoundGeneratedByJoint(boost::shared_ptr<const Joint>& joint) const
{
	if (isJointRevolute(joint) )
	{
		return joint->getAxis() * getInterpolationVelocityBound(joint);
	}
	else
	{
		return Vec3f(0.0, 0.0, 0.0);		
	}
}

FCL_REAL ModelBound::getAbsoluteAngularVelocityBoundGeneratedByJoint(boost::shared_ptr<const Joint>& joint) const
{
	FCL_REAL velocity;

	if (isJointRevolute(joint) )
	{
		return std::abs(getInterpolationVelocityBound(joint) );
	}
	else
	{
		return 0.0;
	}

	return velocity;
}


FCL_REAL ModelBound::getAccumulatedAngularBound(boost::shared_ptr<const Joint>& joint, bool is_directional) const
{
	FCL_REAL angular_bound = 0;

	if (is_directional)
	{
		angular_bound = getCurrentDirection().cross(getAngularVelocityBoundGeneratedByJoint(joint)).length();
	}
	else
	{
		angular_bound = getAngularVelocityBoundGeneratedByJoint(joint).length();
	}

	addAngularBoundAccumulation(angular_bound);		

	return getAngularBoundAccumulation();
}

FCL_REAL ModelBound::getVectorLengthBoundToParent(boost::shared_ptr<const Joint>& joint) const
{	
	boost::shared_ptr<const Joint> joint_parent = getJointParent(joint);	

	// TODO: ask Jia Pan what exactly getTransformToParent means
	// Is it transformation from joint's coordinates to parent's coordinates
	// or it is transformation from parent's coordinates to joint's coordinates?
	// I suggest the second option in spite of the method's name.
	Vec3f vec = joint->getTransformToParent().getTranslation();

	if (isJointTranslational(joint_parent) )
	{
		boost::shared_ptr<const Interpolation> parent_interp = getInterpolation(joint_parent);

		Vec3f movement = joint_parent->getAxis() * parent_interp->getMovementLengthBound(getCurrentTime() );

		vec += movement;
	}	

	return vec.length();
}

bool ModelBound::isJointRevolute(boost::shared_ptr<const Joint>& joint) const
{
	JointType joint_type = joint->getJointType();

	switch (joint_type)
	{
	case JT_PRISMATIC:
		return false;
		break;
	case JT_REVOLUTE:
		return true;
		break;
	}

	return false;
}

bool ModelBound::isJointTranslational(boost::shared_ptr<const Joint>& joint) const
{
	return !isJointRevolute(joint);
}

boost::shared_ptr<const Joint> ModelBound::pop(std::vector<boost::shared_ptr<const Joint> >& vec) const
{
	boost::shared_ptr<const Joint> joint = vec.back();
	vec.pop_back();	 

	return joint;
}

void ModelBound::setCurrentTime(const FCL_REAL& time)
{
	time_ = time;
}

FCL_REAL ModelBound::getCurrentTime() const
{
	return time_;
}	

void ModelBound::setCurrentDirection(const Vec3f& direction)
{
	direction_ = direction;
}

Vec3f ModelBound::getCurrentDirection() const
{
	return direction_;
}

void ModelBound::resetAngularBoundAccumulation()
{
	accumulated_angular_bound_ = 0.0;
}

void ModelBound::addAngularBoundAccumulation(const FCL_REAL& accumulation) const
{
	accumulated_angular_bound_ += accumulation;
}

FCL_REAL ModelBound::getAngularBoundAccumulation() const
{
	return accumulated_angular_bound_;
}

} /* namespace collection */