#include "fcl/articulated_model/model_bound.h"

#include "fcl/articulated_model/model.h"
#include "fcl/articulated_model/model_config.h"
#include "fcl/articulated_model/joint.h"
#include "fcl/articulated_model/joint_config.h"
#include "fcl/ccd/interpolation/interpolation.h"
#include "fcl/ccd/interpolation/interpolation_factory.h"

#include <boost/assert.hpp>

namespace fcl 
{

ModelBound::ModelBound(boost::shared_ptr<const Model> model, 
	boost::shared_ptr<const ModelConfig> cfg_start, boost::shared_ptr<const ModelConfig> cfg_end) :
  model_(model),
  cfg_start_(cfg_start),
  cfg_end_(cfg_end)
{
	initJointsInterpolations();
	initJointsParentTree();
}

void ModelBound::initJointsInterpolations()
{
	/*boost::shared_ptr<fcl::Joint> j;
	std::string test = j->getName();*/

	std::vector<boost::shared_ptr<fcl::Joint> > joints = model_->getJoints();
	std::vector<boost::shared_ptr<fcl::Joint> >::iterator it;

	for (it = joints.begin(); it != joints.end(); ++it)
	{
		boost::shared_ptr<Joint>& joint = (*it);

		// works just for JT_PRISMATIC, JT_REVOLUTE joint types
		BOOST_ASSERT_MSG((joint->getJointType() == JT_PRISMATIC) || (joint->getJointType() == JT_PRISMATIC),
			"Joint type not supported yet");

		const std::string& joint_name = ""; //joint->getName();
		const InterpolationType joint_interpolation_type = model_->getJointInterpolationType(joint_name);

		const FCL_REAL joint_start_value = cfg_start_->getJointConfigByJointName(joint_name).getValue(0);
		const FCL_REAL joint_end_value = cfg_end_->getJointConfigByJointName(joint_name).getValue(0);

		joints_interpolations_[joint_name] =
			InterpolationFactory::instance().create(joint_interpolation_type, joint_start_value, joint_end_value);
	}	
}

void ModelBound::initJointsParentTree()
{
	joints_parent_tree_ = model_->getParentTree();
}

FCL_REAL ModelBound::getMotionBound(const std::string& joint_name, const FCL_REAL time, 
	const Vec3f direction, const FCL_REAL body_max_distance_from_origin)
{
	FCL_REAL motion_bound = 0;
	joints_accumulated_angular_bound_.clear();

	setCurrentTime(time);
	setCurrentDirection(direction);

	std::vector<boost::shared_ptr<const Joint> > joints_chain = getJointsChainFromLastJoint(joint_name);	

	boost::shared_ptr<const Joint> root_joint = pop(joints_chain);	

	boost::shared_ptr<const Joint> joint = pop(joints_chain);	

	// add motion bound generated by root joint
	motion_bound += getRootOneStepMotionBound(root_joint, joint);

	// add motion bound generated by other joints
	while (!joints_chain.empty() )
	{
		boost::shared_ptr<const Joint> child_joint = pop(joints_chain);

		motion_bound += getOneStepMotionBound(joint, child_joint);

		joint = child_joint;
	}

	// add motion bound for object (rigid body) fixed to last joint
	motion_bound += getOneStepBodyMotionBound(joint, body_max_distance_from_origin);

	return motion_bound;
}

std::vector<boost::shared_ptr<const Joint> >
	ModelBound::getJointsChainFromLastJoint(const std::string& last_joint_name) const
{
	std::vector<boost::shared_ptr<const Joint> > joints_chain;

	boost::shared_ptr<const Joint> joint = model_->getJoint(last_joint_name);

	while (joint.use_count() != 0)
	{
		joints_chain.push_back(joint);

		joint = getJointParent(joint->getName() );
	}

	return joints_chain;
}

boost::shared_ptr<const Joint> ModelBound::getJointParent(const std::string& joint_name) const 
{
	return model_->getJoint(getJointParentName(joint_name) );
}

std::string ModelBound::getJointParentName(const std::string& joint_name) const
{
	std::map<std::string, std::string>::const_iterator it = joints_parent_tree_.find(joint_name);
	BOOST_ASSERT_MSG((it != joints_parent_tree_.end()), "Joint name not valid");

	return it->second;
}

boost::shared_ptr<const Joint> ModelBound::pop(std::vector<boost::shared_ptr<const Joint> >& vec)
{
	boost::shared_ptr<const Joint> joint = vec.back();
	vec.pop_back();	 

	return joint;
}

FCL_REAL ModelBound::getRootOneStepMotionBound(const std::string& from_joint_name, const std::string& to_joint_name)
{
	FCL_REAL motion_bound = 0;

	motion_bound += 
		(getLinearVelocityBoundGeneratedByJoint(from_joint_name) * getCurrentDirection() ).length();

	motion_bound +=  getRootJointAccumulatedAngularBound(from_joint_name) *
		getVectorLengthBoundToParent(to_joint_name);

	return motion_bound;
}

FCL_REAL ModelBound::getRootOneStepMotionBound(boost::shared_ptr<const Joint> from, boost::shared_ptr<const Joint> to)
{
	return getRootOneStepMotionBound(from->getName(), to->getName() );
}

Vec3f ModelBound::getLinearVelocityBoundGeneratedByJoint(const std::string& joint_name) const
{
	Vec3f vector;

	boost::shared_ptr<Joint> joint = model_->getJoint(joint_name);	

	if (isJointRevolute(joint) )
	{
		vector = Vec3f(0.0, 0.0, 0.0);
	}
	else
	{
		vector = joint->getAxis() * getInterpolationVelocityBound(joint_name);
	}

	return vector;
}

Vec3f ModelBound::getAngularVelocityBoundGeneratedByJoint(const std::string& joint_name) const
{
	Vec3f vector;

	boost::shared_ptr<Joint> joint = model_->getJoint(joint_name);	

	if (isJointTranslational(joint) )
	{
		vector = Vec3f(0.0, 0.0, 0.0);
	}
	else
	{
		vector = joint->getAxis() * getInterpolationVelocityBound(joint_name);
	}

	return vector;
}

FCL_REAL ModelBound::getAbsoluteLinearVelocityBoundGeneratedByJoint(const std::string& joint_name) const
{
	FCL_REAL velocity;

	if (isJointRevolute(joint_name) )
	{
		velocity = 0.0;
	}
	else
	{
		velocity = std::abs(getInterpolationVelocityBound(joint_name));
	}

	return velocity;
}

FCL_REAL ModelBound::getAbsoluteAngularVelocityBoundGeneratedByJoint(const std::string& joint_name) const
{
	FCL_REAL velocity;

	if (isJointTranslational(joint_name) )
	{
		velocity = 0.0;
	}
	else
	{
		velocity = std::abs(getInterpolationVelocityBound(joint_name) );
	}

	return velocity;
}

FCL_REAL ModelBound::getVectorLengthBoundToParent(boost::shared_ptr<Joint> child) const
{
	return getVectorLengthBoundToParent(child->getName() );
}

FCL_REAL ModelBound::getVectorLengthBoundToParent(const std::string& child_name) const
{	
	boost::shared_ptr<const Joint> joint = model_->getJoint(child_name);
	boost::shared_ptr<const Joint> joint_parent = getJointParent(child_name);	

	// TODO: check if usage of getTransformToParent() is correct here
	Vec3f vec = joint->getTransformToParent().getTranslation();

	if (isJointTranslational(joint_parent) )
	{
		boost::shared_ptr<const Interpolation> parent_interp = getInterpolation(joint_parent->getName() );

		Vec3f movement = joint_parent->getAxis() * parent_interp->getMovementLengthBound(getCurrentTime() );

		vec += movement;
	}	

	return vec.length();
}

boost::shared_ptr<Interpolation> ModelBound::getInterpolation(const std::string& joint_name) const
{
	std::map<std::string, boost::shared_ptr<Interpolation> >::const_iterator it = joints_interpolations_.find(joint_name);
	BOOST_ASSERT_MSG((it != joints_interpolations_.end()), "Joint name not valid");

	return it->second;
}

FCL_REAL ModelBound::getInterpolationVelocityBound(const std::string& joint_name) const
{
	boost::shared_ptr<const Interpolation> interp = getInterpolation(joint_name);	

	return interp->getVelocityBound(getCurrentTime() );
}

bool ModelBound::isJointRevolute(const std::string& joint_name) const
{
	boost::shared_ptr<Joint> joint = model_->getJoint(joint_name);	
	JointType joint_type = joint->getJointType();

	switch (joint_type)
	{
		case JT_PRISMATIC:
			return true;
			break;
		case JT_REVOLUTE:
			return false;
			break;
	}

	return false;
}

bool ModelBound::isJointTranslational(const std::string& joint_name) const
{
	return !isJointRevolute(joint_name);
}

bool ModelBound::isJointRevolute(boost::shared_ptr<const Joint> joint) const
{
	bool is_revolute = false;

	switch (joint->getJointType() )
	{
		case JT_REVOLUTE:
			is_revolute = true;
			break;
	}

	return is_revolute;
}

bool ModelBound::isJointTranslational(boost::shared_ptr<const Joint> joint) const
{
	return !isJointRevolute(joint);
}

FCL_REAL ModelBound::getOneStepMotionBound(const std::string& from_joint_name, const std::string& to_joint_name)
{
	FCL_REAL motion_bound = 0;

	motion_bound += getAbsoluteLinearVelocityBoundGeneratedByJoint(from_joint_name);

	motion_bound +=  getJointAccumulatedAngularBound(from_joint_name) *
		getVectorLengthBoundToParent(to_joint_name);

	return motion_bound;
}

FCL_REAL ModelBound::getOneStepMotionBound(boost::shared_ptr<const Joint> from, boost::shared_ptr<const Joint> to)
{
	return getOneStepMotionBound(from->getName(), to->getName() );
}

FCL_REAL ModelBound::getOneStepBodyMotionBound
	(const std::string& joint_name, const FCL_REAL body_max_distance_from_origin)
{
	FCL_REAL motion_bound = 0;

	motion_bound += getAbsoluteLinearVelocityBoundGeneratedByJoint(joint_name);

	motion_bound +=  getJointAccumulatedAngularBound(joint_name) * body_max_distance_from_origin;

	return motion_bound;
}
FCL_REAL ModelBound::getOneStepBodyMotionBound
	(boost::shared_ptr<const Joint> joint, const FCL_REAL body_max_distance_from_origin)
{
	return getOneStepBodyMotionBound(joint->getName(), body_max_distance_from_origin);
}

FCL_REAL ModelBound::getRootJointAccumulatedAngularBound(const std::string& joint_name)
{
	FCL_REAL angular_bound = 
		getCurrentDirection().cross(getAngularVelocityBoundGeneratedByJoint(joint_name)).length();

	joints_accumulated_angular_bound_.push_back(angular_bound);

	return angular_bound;
}

FCL_REAL ModelBound::getJointAccumulatedAngularBound(const std::string& joint_name)
{
	FCL_REAL angular_bound = getAngularVelocityBoundGeneratedByJoint(joint_name).length();

	angular_bound += joints_accumulated_angular_bound_.back();		
	joints_accumulated_angular_bound_.push_back(angular_bound);

	return angular_bound;
}

void ModelBound::setCurrentTime(const FCL_REAL time)
{
	time_ = time;
}

FCL_REAL ModelBound::getCurrentTime() const
{
	return time_;
}	

void ModelBound::setCurrentDirection(const Vec3f direction)
{
	direction_ = direction;
}

Vec3f ModelBound::getCurrentDirection() const
{
	return direction_;
}

} /* namespace collection */