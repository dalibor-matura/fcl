#include "fcl/articulated_model/model_bound.h"

#include "fcl/articulated_model/model.h"
#include "fcl/articulated_model/model_config.h"
#include "fcl/articulated_model/link.h"
#include "fcl/articulated_model/joint.h"
#include "fcl/articulated_model/joint_config.h"
#include "fcl/articulated_model/joint_bound_info.h"

#include <boost/assert.hpp>

namespace fcl 
{

ModelBound::ModelBound(boost::shared_ptr<Model> model, 	boost::shared_ptr<const ModelConfig> cfg_start,
	boost::shared_ptr<const ModelConfig> cfg_end, boost::shared_ptr<const Link> bounded_link) :

	model_(model),
	cfg_start_(cfg_start),
	cfg_end_(cfg_end),
	bounded_link_(bounded_link),
	joint_bound_info_(new JointBoundInfo(model, cfg_start, cfg_end) )
{	
	initJointsChain();
}

void ModelBound::initJointsChain()
{
	joints_chain_ = getJointsChainFromLastJoint(getLastJoint() );
}

boost::shared_ptr<Joint> ModelBound::getLastJoint() const
{
	return bounded_link_->getParentJoint();
}

std::vector<boost::shared_ptr<const Joint> >
ModelBound::getJointsChainFromLastJoint(const boost::shared_ptr<const Joint>& last_joint) const
{
	std::vector<boost::shared_ptr<const Joint> > joints_chain;

	boost::shared_ptr<const Joint> joint = last_joint;

	while (joint.use_count() != 0)
	{
		joints_chain.push_back(joint);

		joint = model_->getJointParent(joint);
	}

	return joints_chain;
}

const std::vector<boost::shared_ptr<const Joint> >& ModelBound::getJointsChain() const
{
	return joints_chain_;
}

FCL_REAL ModelBound::getMotionBound(const FCL_REAL& time, const Vec3f& direction, 
	const FCL_REAL max_distance_from_joint_center)
{
	FCL_REAL motion_bound = 0;
	
	joint_bound_info_->setCurrentTime(time);
	setCurrentDirection(direction);
	
	resetAngularBoundAccumulation();

	// add motion bound generated by other joints
	motion_bound += getJointsChainMotionBound();

	// add motion bound for collision object (rigid body) fixed to the link of the last joint
	motion_bound += getObjectMotionBoundInLastJointFrame(max_distance_from_joint_center);

	return motion_bound;
}

FCL_REAL ModelBound::getJointsChainMotionBound() const
{
	FCL_REAL motion_bound = 0;
	
	std::vector<boost::shared_ptr<const Joint> >::const_reverse_iterator 
		reverse_it = getJointsChain().rbegin();

	// skip root joint
	if (reverse_it != getJointsChain().rend() )
	{
		++reverse_it;
	}

	for ( ; reverse_it != getJointsChain().rend(); ++reverse_it)
	{
		const boost::shared_ptr<const Joint>& joint = *reverse_it;

		motion_bound += getMotionBoundInParentFrame(joint);
	}

	return motion_bound;
}

FCL_REAL ModelBound::getMotionBoundInParentFrame(const boost::shared_ptr<const Joint>& joint) const 
{
	boost::shared_ptr<const Joint> parent = model_->getJointParent(joint);

	BOOST_ASSERT_MSG(parent.use_count() != 0, "Joint is not assigned.");

	if (isRoot(parent) )
	{
		return getDirectionalMotionBoundInParentFrame(joint);
	}
	else
	{
		return getSimpleMotionBoundInParentFrame(joint);
	}
}

FCL_REAL ModelBound::getDirectionalMotionBoundInParentFrame(const boost::shared_ptr<const Joint>& joint) const 
{
	FCL_REAL motion_bound = 0;

	const boost::shared_ptr<const Joint> parent = model_->getJointParent(joint);

	motion_bound += (joint_bound_info_->getLinearVelocityBound(parent) * getCurrentDirection() ).length();
	motion_bound += getAccumulatedAngularBound(parent, true) * joint_bound_info_->getVectorLengthBound(parent, joint);

	return motion_bound;
}

FCL_REAL ModelBound::getSimpleMotionBoundInParentFrame(const boost::shared_ptr<const Joint>& joint) const 
{
	FCL_REAL motion_bound = 0;

	boost::shared_ptr<const Joint> parent = model_->getJointParent(joint);

	motion_bound += joint_bound_info_->getAbsoluteLinearVelocityBound(parent);
	motion_bound +=  getAccumulatedAngularBound(parent) * joint_bound_info_->getVectorLengthBound(parent, joint);

	return motion_bound;
}

FCL_REAL ModelBound::getObjectMotionBoundInLastJointFrame(const FCL_REAL max_distance_from_joint_center) const
{
	FCL_REAL motion_bound = 0;

	boost::shared_ptr<const Joint> joint = getLastJoint();

	if (joint.use_count() == 0)
	{
		return 0;
	}

	motion_bound += joint_bound_info_->getAbsoluteLinearVelocityBound(joint);
	motion_bound += getAccumulatedAngularBound(joint) * max_distance_from_joint_center;

	return motion_bound;
}

bool ModelBound::isRoot(const boost::shared_ptr<const Joint>& joint) const
{
	boost::shared_ptr<const Joint> parent = model_->getJointParent(joint);	

	return (parent.use_count() == 0);
}

FCL_REAL ModelBound::getAccumulatedAngularBound(const boost::shared_ptr<const Joint>& joint, bool is_directional) const
{
	FCL_REAL angular_bound = 0;

	if (is_directional)
	{
		angular_bound = getCurrentDirection().cross(joint_bound_info_->getAngularVelocityBound(joint)).length();
	}
	else
	{
		angular_bound = joint_bound_info_->getAngularVelocityBound(joint).length();
	}

	addAngularBoundAccumulation(angular_bound);		

	return getAngularBoundAccumulation();
}

void ModelBound::setCurrentDirection(const Vec3f& direction)
{
	direction_ = direction;
}

Vec3f ModelBound::getCurrentDirection() const
{
	return direction_;
}

void ModelBound::resetAngularBoundAccumulation()
{
	accumulated_angular_bound_ = 0.0;
}

void ModelBound::addAngularBoundAccumulation(const FCL_REAL& accumulation) const
{
	accumulated_angular_bound_ += accumulation;
}

FCL_REAL ModelBound::getAngularBoundAccumulation() const
{
	return accumulated_angular_bound_;
}

} /* namespace collection */